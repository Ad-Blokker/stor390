---
title: "Words and strings in R"
output: slidy_presentation
---

## Why this matters

- A lot of interesting data comes in the form of text. 

- Messy data often can be cleaned up by treating it as text and editing---for example a column that should be numeric but that has commas in it. 

## What you will learn

- **Logic of regular expressions**
- **Match** one string to another with regular expressions
- **Extract** a pattern from a series of strings
- **Look-ahead** regular expressions
- How to **apply** visualization and summarization to text data


## Resources
- Reading these and doing the homeworks will show you how to use the basic tools:
- [Regular expressions in R](http://stat545.com/block022_regular-expression.html)
- [Strings chapter](http://r4ds.had.co.nz/strings.html) in R for Data Science
- This lecture will apply those tools to an actual dataset

```{r prep, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
library(tidyr)
library(stringr)
library(readr)
library(dplyr)
library(ggplot2)
library(RColorBrewer)

# read_lines instead of readLines just because of https issue
# first six lines are intro stuff
beauty <- read_lines('https://cdn.getdatajoy.com/kx8ju9/beauty_beast_raw.txt', skip = 6) %>% 
  str_trim(side = "both") %>% paste(collapse = ";")

# A hack to avoid annoying issues later that are not important for the analysis
beauty <- str_replace(beauty, " \\(ex. COGSWORTH\\):", ":") %>% str_replace(" \\(esp. LUMIERE\\):", ":")

# little annoying or statement for MRS. POTTS. Can't rearrage the previous statement without getting more
codes <- unique(str_extract_all(beauty, "[A-Z]+[\\s0-9[:punct:]]*:|MRS. POTTS:")[[1]])
codes_list <- as.list(paste0(seq(from = 100, to = 100 + length(codes) - 1), ">"))
names(codes_list) <- codes

beauty <- str_replace_all(beauty, codes_list) %>% 
  str_replace("</pre>", "") %>%
  # first removing the directions between two brackets
  str_replace_all("(\\(){1}[A-Za-z0-9\\s,.;:'!?]*(\\)){1}", "") %>%
  # now getting the dangling brackets with open ends at the end of the line or dangling brackets
  str_replace_all("(\\(){1}[A-Za-z0-9\\s,.;:'!?]*(\\))*", "")

beauty <- data.frame(person = str_extract_all(beauty, "[0-9]{3}>")[[1]],
                     line = str_extract_all(beauty, "[A-z[:punct:][:space:]]+(?![0-9]{3}>)")[[1]])

# Now switch the codes back to names and clean up a little
names(codes) <- unlist(codes_list)
codes <- as.list(codes)
beauty$person <- str_replace_all(beauty$person, codes) %>% str_replace_all(":", "")
beauty$line <- str_trim(beauty$line, side = "both") %>% str_replace_all(";+", ";")


# Now we have a data frame with lines in one column, speakers in another



```


## Beauty and the Beast
![](http://img.lum.dolimg.com/v1/images/gallery_beautyandthebeast_03_81aeab2e.jpeg?region=0%2C0%2C1580%2C880)

## Our data
- Full transscript of the movie
- Already cleaned and loaded in a data frame
- One line per line of dialogue
- Two variables: speaker name and line spoken
- Rows are in speaking order

## Quick look
```{r, echo=TRUE}
library(stringr)
library(dplyr)

str(beauty)
tail(beauty)
```

## Matching

- A `string' is a sequence of characters
- Matching one string to another is essential to text processing
- **Example:** 'animal' matches the start of 'animalia' but not of `malina'
- Regular expressions will help us **be more precise in deciding what is a match**

## Application: How many times do characters speak?
- Match a name to the *person* character vector to count how many lines that person speaks

```{r, echo=TRUE}
sum(str_count(beauty$person, "GASTON"))
sum(grepl("GASTON", beauty$person))
sum(str_count(beauty$person, "BELLE"))
sum(str_count(beauty$person, "BEAST"))
sum(str_count(beauty$person, "PIERRE"))
```

- Doesn't tell us how much time each of them is speaking

## Extracting, replacing strings and regular expression logic
![](http://img.lum.dolimg.com/v1/images/gallery_beautyandthebeast_15_6c38d594.jpeg?region=0%2C0%2C1580%2C880)

## Regular expressions
- Resources have lots of details on these and the *stringr* package. **Read them**

General regular expression logic:

- $[\ldots]$ matches any of the items in brackets

- place the **frequency quantifiers after the items** they refer to. See the references for information on frequency quantifiers, which give constraints on how many times the pattern can be matched

- Use **parentheses for grouping patterns,** typically to give specific quantifiers or to control order of operations. You can do more with parentheses, as we'll see in the next section. For example *pl?ot* will match *pot* or *plot* but *(pl)?ot* matches *plot*, *lot*, *pot* or *ot*

- *expression1|expression2* matches **expression1 OR expression2.** 

- *expression1expression2* matches **expression1 AND expression2** in the order given.

**Think of AND as multiplication, OR as addition.** The orders of operations are the same. As in algebra, use parentheses to control the order of operations.

## Example: Regular expressions and extraction
```{r, echo=TRUE}
# Matches capital letters AND subsequent numbers OR lower case letters AND subsequent punctuation
str_extract_all("TOWNFOLK2 townfolk!", "[A-Z]+[0-9]+|[a-z]+[[:punct:]]+")

# Matches (capitals AND numbers OR lower case) AND punctuation
str_extract_all("TOWNFOLK2 townfolk!", "([A-Z]+[0-9]+|[a-z]+)[[:punct:]]+")

# Matches capitals AND (numbers OR lower case AND punctuation)
str_extract_all("TOWNFOLK2 townfolk!", "[A-Z]+([0-9]+|[a-z]+[[:punct:]]+)")

```

## Application: Replacement
Let's use some regular expressions to group the anonymous speakers in the script. 

*Note: Please forgive the use of the word 'bimbettes.' It was in the data and I cringe to type it!*

```{r, echo=TRUE}
beauty$person <- str_replace_all(beauty$person, "TOWNSFOLK[0-9\\s]*", "townsfolk") %>%
  str_replace_all("CRONY[0-9\\s]*|CRONIES", "crony") %>%
  str_replace_all("WOMAN[0-9\\s]*|BIMBETTES?[0-9\\s]*", "woman") %>%
  str_replace_all("MAN[0-9\\s]*|MEN", "man") %>%
  str_replace_all("GROUP[0-9\\s]*|ALL|BOTH|CHORUS|OBJECTS|BYSTANDERS|MUGS|MOB", "group") %>%
  tolower

```

## String data to summaries
- Use summary and grouping functions you already learned to summarize the number of text characters for movie characters among the top 10. 

You will do more in your homework. *BB NOTE: remove this if the homework ends up being different. Also the stat argument is deprecated in the most recent ggplot. Need to update. Right now just a scatter plot*

```{r, echo=TRUE, fig.width=10}
group_by(beauty, person) %>% 
  summarise(N = sum(nchar(line))) %>%
  arrange(desc(N)) %>% slice(1:10) %>%
  qplot(data = ., geom = "point", x = person, y = N) + 
  theme_minimal() + theme(axis.text.x  = element_text(angle=75, vjust=0.5, size=10), axis.title.x = element_blank())
```

## To see much more
Lecture notes have 

- more examples 
- more-complicated uses of regular expressions to look at and clean up the raw data we used

## Homework
*BB note: INSERT*
